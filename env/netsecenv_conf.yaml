# Configuration file for the NetSecGame environment

# Documentation
# Apart from the IP address and networks, you can also use 'all_local' for all hosts that are not in the internet (The environment knows them and is generic for any future game).
#
# Known networks: The networks known by the agents
# Example:
# known_networks: [192.168.1.0/24, 192.168.3.0/24]
# known_networks: ['all_local']

# Known hosts: The hosts known but maybe not controlled by the agents
# Example
# known_hosts: [192.168.1.1, 192.168.1.2]
# known_hosts: ['all_local']

# Controlled Hosts: The hosts the agent controlls and can execute actions from them, and see their data.
# controlled_hosts: [213.47.23.195, 192.168.1.3]
# The special word random, assigns a random IP from those available in the game. So every time the agent starts, it controlls a different host. This is critical fro Reinforcement Learning (or tries to win, depending if you put it in start or win position)
# controlled_hosts: [213.47.23.195, random]
# The special word 'all_local' can be used to include all local IPs.
# controlled_hosts: ['all_local']

# Known services: Services known by the agent.
# Services are defined as a target host where the service must be, and then a description in the form 'name, type, version, is_local'
# Name can be anything you want. Type too. Version too. Is_local is a boolean to specify if the service is opened to the network or only in the localhost.
# Example:
# known_services: {192.168.1.3: [Local system, lanman server, 10.0.19041, False], 192.168.1.4: [Other system, SMB server, 21.2.39421, False]}

# Known data: Data known by the agents.
# In known data, put the target host that must have the data and which data in format: [user owner, data]
# Example to fix two data in one host. User1 and User5 can be any string you want. DataFromServer1 is actually the data, like a file content.
# known_data: {213.47.23.195: [[User1, DataFromServer1], [User5, DataFromServer5]]}
# Example to fix the data in two host
# known_data: {213.47.23.195: [User1, DataFromServer1], 192.168.3.1: [User3, Data3FromServer3]}
# Example to ask a random data in a specific server. Putting 'random' in the data, forces the env to randomly choose where the data is. 
# Very useful to set random goals that are important for Reinforcement Learning.
# known_data: {213.47.23.195: [random]}

# Known blocks. Firewall blocks known by the agent.
# This is a dictionary. The Key is the _target host_ where the rule is applied. The value of the dictionary is a list of IPs that are blocked in that _target host_.
# The blocks are applied as everything going to and from those IPs.
# Example: In the host 192.168.2.2, block all connections coming or going _to_ and _from_ 192.168.1.3 and 192.168.1.4
# known_blocks: {192.168.2.2: [192.168.1.3, 192.168.1.4]}
# You can also use the wildcard string 'all_routers', and 'all_attackers', to mean that all the controlled hosts of all the attackers should be in this list in order to win

coordinator:
  # Define the conf for all the 'attacker' agents.
  agents:
    Attacker:
      goal:
        description: "Exfiltrate data to '213.47.23.195'"
        # Put randomize_goal_every_episode in True if you put any of the goal values in 'random'
        is_any_part_of_goal_random: True
        known_networks: []
        known_hosts: []
        controlled_hosts: []
        known_services: {}
        known_data: {213.47.23.195: [[User1,DataFromServer1]]}
        known_blocks: {}

      start_position:
        known_networks: []
        known_hosts: []
        # If the attacker has as goal to put data in a public IP command and control server, then it must also controll it from the start.
        controlled_hosts: [213.47.23.195, random]
        known_services: {}
        known_data: {}
        known_blocks: {}

    Defender:
      goal:
        description: "Block all attackers"
        is_any_part_of_goal_random: False
        known_networks: []
        known_hosts: []
        controlled_hosts: []
        known_services: {}
        known_data: {}
        # Default for the defender is not to have any goal in the blocks because the generic goal of the defender is to stop the attackers from winning. Check documentation.
        known_blocks: {}

      start_position:
        known_networks: ['all_local']
        known_hosts: ['all_local']
        controlled_hosts: ['all_local']
        known_services: {'all_local': ['all_local']}
        known_data: {'all_local': ['all_local']}
        known_blocks: {'all_local': ['all_local']}

  DefenderType:
    # types are StochasticDefender and NoDefender
    #type: 'StochasticDefender'
    #type: 'StochasticWithThreshold'
    #type: 'NoDefender'
    type: 'Agents'
    # The following configurations only apply to the type of defenders that are not `Agents`. `Agents` means that the defender
    # is an agent and its configuration is `coordinator.agents.defenders`.
    tw_size: 5
    thresholds:
      scan_network: # if both conditions are true, you are never detected
        consecutive_actions: 2 # min amount of consecutive actions you can do without detection
        tw_ratio: 0.25 # min ratio of actions in the tw below which you are not detected
      find_services:
        consecutive_actions: 3
        tw_ratio: 0.3
      exploit_service:
        repeated_actions_episode: 2
        tw_ratio: 0.25
      find_data:
        tw_ratio: 0.5
        repeated_actions_episode: 2
      exfiltrate_data:
        consecutive_actions: 2
        tw_ratio: 0.25
    action_detetection_prob:
      scan_network: 0.05
      find_services: 0.075
      exploit_service: 0.1
      find_data: 0.025
      exfiltrate_data: 0.025

env:
  # random means to choose the seed in a random way, so it is not fixed
  random_seed: 'random'
  # Or you can fix the seed
  # random_seed: 42
  scenario: 'scenario1'
  max_steps: 100
  store_replay_buffer: False
  use_dynamic_addresses: False
  use_global_defender: False
  use_firewall: True
  save_trajectories: False
  goal_reward: 100
  detection_reward: -5
  step_reward: -1
  actions:
    scan_network:
      prob_success: 1.0
    find_services:
      prob_success: 1.0
    exploit_service:
      prob_success: 1.0
    find_data:
      prob_success: 1.0
    exfiltrate_data:
      prob_success: 1.0